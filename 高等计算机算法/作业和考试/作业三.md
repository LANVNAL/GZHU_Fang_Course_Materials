# 写出0/1背包问题的最优解构造算法



```python
def bag(n, c, w, v):
    # 保存状态
    value = [[0 for j in range(c + 1)] for i in range(n + 1)]
    for i in range(1, n + 1):
        for j in range(1, c + 1):
            value[i][j] = value[i - 1][j]
            if j >= w[i - 1] and value[i][j] < value[i - 1][j - w[i - 1]] + v[i - 1]:
                value[i][j] = value[i - 1][j - w[i - 1]] + v[i - 1]
    return value

def show(n, c, w, value):
    print('最大价值为:', value[n][c])
    x = [False for i in range(n)]
    j = c
    for i in range(n, 0, -1):
        if value[i][j] > value[i - 1][j]:
            x[i - 1] = True
            j -= w[i - 1]
    print('背包中所装物品为:')
    for i in range(n):
        if x[i]:
            print('第', i+1, '个,', end='')

n = 4  #物品数量
c = 5  #容量
w = [2, 1, 3, 2]  #物品重量
v = [12, 10, 20, 15]  #物品价值
value = bag(n, c, w, v)
for _ in value:
    print(_)

show(n,c,w,value)

```



# 动态规划思想在KMP算法中是怎样体现的

kmp 算法的核心是计算 Next 数组。Next[] 为要计算的数组，Next[j] 表示长度为 j 的字符串"P[0]P[1]...P[j-1]"的前缀等于后缀的最长长度，比如对于字符串 P 为"abCdabCe"来说其 Next[7]为 3 因为 abC 的长度为 3， 边界值 Next[0] = 0, Next[1] = 0

动态规划状态函数为 f(int j, char x)，f(j,x)表示长度为 j+1 的字符串"P[0]P[1]...P[j-1]x"
的前缀等于后缀的最长长度，比如对于字符串 P 为"abCdabCe"来说其 f(6, 'C')为 3 因为 abC 的长度为 3，很直接的我们可以知道 Next[j] = f(j-1, P[j])

f(j, x) =

1. 当 x 等于 P[Next[j]+1] 时，f(j, x) = Next[j] + 1

2. 当 x 不等于 P[Next[j]+1] ， 且 j 为 0 时， 这就是边界条件，此时 f(j, x) = 0

3. 当 x 不等于 P[Next[j]+1] ， 且 j 不为 0 时，f(j, x) = f(Next[j], x)



参考：

> https://www.cnblogs.com/dusf/p/kmp.html