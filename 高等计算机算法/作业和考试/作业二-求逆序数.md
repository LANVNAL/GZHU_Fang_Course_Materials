要求一个数组的逆序数



先分析一下，对于数组S，将它拆成两个数组A和B后，整个S的逆序数就变成了三个部分。分别是A数组之间的逆序数、B数组之间的逆序数，以及AB两个数组之间的逆序数，也就是一个元素在A中，一个元素在B中的逆序数对。即使A数组中的元素交换位置，只会影响A数组之间的逆序数，并不会影响B以及AB之间构成的逆序数。因为A中的元素即使交换位置，也在B数组所有元素之前。既然A和B当中的元素无论怎么交换顺序也不会影响对方的结果，那么我们就可以放心地使用分治算法来解决了。

调整A或者B当中的元素顺序，并不会改变横跨AB逆序数的数量，通过递归已经求到了A和B中各自逆序数对的数量，所以我们存下来之后，就可以对A和B中的元素进行排序了。A和B中元素有序了之后，我们可以用插入排序的方法，将A中的元素依次插入B当中。

假设我们把![[公式]](https://www.zhihu.com/equation?tex=a_i)这个元素插入B数组当中j的位置。由于之前![[公式]](https://www.zhihu.com/equation?tex=a_i)排在B这j个元素之前，所以构成了j个逆序数对。我们对于所有A中的元素![[公式]](https://www.zhihu.com/equation?tex=a_i)求出它在B数组所有插入的位置j，然后对j求和即可。



```python
def inverse_num(array):
    n = len(array)
    if n <= 1:
        return 0, array

    mid = n // 2
    # 将数组拆分为二往下递归
    inverse_l, arr_l = inverse_num(array[:mid])
    inverse_r, arr_r = inverse_num(array[mid:])

    nl, nr = len(arr_l), len(arr_r)

    # 插入最大的int作为标兵，可以简化判断超界的代码
    arr_l.append(sys.maxsize)
    arr_r.append(sys.maxsize)

    i, j = 0, 0
    new_arr = []
    # 存储array对应的逆序数
    inverse = inverse_l + inverse_r

    while i < nl or j < nr:
        if arr_l[i] <= arr_r[j]:
            # 插入A[i]的时候逆序数增加j，因为A[i]之前放在这j个元素之前
            inverse += j
            new_arr.append(arr_l[i])
            i += 1
        else:
            new_arr.append(arr_r[j])
            j += 1
    return inverse, new_arr
```

